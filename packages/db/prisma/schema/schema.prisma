generator client {
  provider = "prisma-client"
  output   = "../generated"
  moduleFormat = "esm"
  runtime = "bun"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============ AUTH MODELS ============

model User {
  id            String    @id @map("_id")
  name          String
  email         String
  emailVerified Boolean
  image         String?
  isAdmin       Boolean   @default(false) @map("is_admin")
  createdAt     DateTime
  updatedAt     DateTime

  // Auth relations
  sessions      Session[]
  accounts      Account[]

  // App relations
  subscriptions     Subscription[]
  tokenBalance      TokenBalance?
  tokenTransactions TokenTransaction[]
  telegramEntities  TelegramEntity[]
  inviteLinks       InviteLink[]

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id @map("_id")
  expiresAt DateTime
  token     String
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id @map("_id")
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

model Verification {
  id         String    @id @map("_id")
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}

// ============ APP MODELS ============

// Plans
model Plan {
  id                String   @id @default(uuid())
  name              String
  description       String?
  type              Int      // PlanType enum
  interval          Int      // PlanInterval enum
  price             Float
  tokensIncluded    Int      @map("tokens_included")
  features          Json?
  isActive          Boolean  @default(true) @map("is_active")
  maxGroups         Int?     @map("max_groups") // null means unlimited
  maxInvitesPerDay  Int?     @map("max_invites_per_day")
  metadata          Json?
  createdAt         DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt         DateTime @updatedAt @map("updated_at") @db.Timestamptz(3)
  deletedAt         DateTime? @map("deleted_at") @db.Timestamptz(3)

  subscriptions Subscription[]

  @@map("plan")
}

// User Subscriptions
model Subscription {
  id          String    @id @default(uuid())
  userId      String    @map("user_id")
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  planId      String    @map("plan_id")
  plan        Plan      @relation(fields: [planId], references: [id])
  status      Int       @default(0) // SubscriptionStatus enum
  startDate   DateTime  @default(now()) @map("start_date") @db.Timestamptz(3)
  endDate     DateTime? @map("end_date") @db.Timestamptz(3)
  autoRenew   Boolean   @default(true) @map("auto_renew")
  cancelledAt DateTime? @map("cancelled_at") @db.Timestamptz(3)
  metadata    Json?
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt   DateTime  @updatedAt @map("updated_at") @db.Timestamptz(3)
  deletedAt   DateTime? @map("deleted_at") @db.Timestamptz(3)

  @@index([userId])
  @@index([planId])
  @@index([status])
  @@map("subscription")
}

// Token Balance
model TokenBalance {
  id          String   @id @default(uuid())
  userId      String   @unique @map("user_id")
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  balance     Int      @default(0)
  totalEarned Int      @default(0) @map("total_earned")
  totalSpent  Int      @default(0) @map("total_spent")
  metadata    Json?
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("token_balance")
}

// Token Transactions
model TokenTransaction {
  id           String    @id @default(uuid())
  userId       String    @map("user_id")
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  type         Int       // TransactionType enum
  status       Int       @default(0) // TransactionStatus enum
  amount       Int       // Positive for credit, negative for debit
  balanceAfter Int       @map("balance_after")
  description  String?
  reference    String?   // External reference like payment ID, invite link ID, etc.
  metadata     Json?     // Store additional info
  createdAt    DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt    DateTime  @updatedAt @map("updated_at") @db.Timestamptz(3)
  deletedAt    DateTime? @map("deleted_at") @db.Timestamptz(3)

  @@index([userId])
  @@index([type])
  @@index([status])
  @@index([createdAt])
  @@index([reference])
  @@map("token_transaction")
}

// Token Cost Configuration - pricing per duration unit
model TokenCostConfig {
  id           String    @id @default(uuid())
  durationUnit Int       @unique @map("duration_unit") // DurationUnit enum (0=minute, 1=hour, 2=day, 3=month, 4=year)
  costPerUnit  Int       @map("cost_per_unit") // tokens per unit
  description  String?
  isActive     Boolean   @default(true) @map("is_active")
  metadata     Json?
  createdAt    DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt    DateTime  @updatedAt @map("updated_at") @db.Timestamptz(3)
  deletedAt    DateTime? @map("deleted_at") @db.Timestamptz(3)

  @@map("token_cost_config")
}

// Telegram Groups/Channels
model TelegramEntity {
  id           String    @id @default(uuid())
  userId       String    @map("user_id")
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  telegramId   String    @unique @map("telegram_id") // Telegram's chat ID
  type         Int       // TelegramEntityType enum
  title        String
  username     String?   // @username if available
  description  String?
  memberCount  Int?      @map("member_count")
  isActive     Boolean   @default(true) @map("is_active")
  botAdded     Boolean   @default(false) @map("bot_added")
  botAddedAt   DateTime? @map("bot_added_at") @db.Timestamptz(3)
  metadata     Json?     // Store additional telegram data
  createdAt    DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt    DateTime  @updatedAt @map("updated_at") @db.Timestamptz(3)
  deletedAt    DateTime? @map("deleted_at") @db.Timestamptz(3)

  inviteLinks  InviteLink[]
  groupMembers GroupMember[]
  joinLogs     JoinLog[]

  @@index([userId])
  @@index([telegramId])
  @@index([type])
  @@map("telegram_entity")
}

// Invite Links
model InviteLink {
  id               String    @id @default(uuid())
  telegramEntityId String    @map("telegram_entity_id")
  telegramEntity   TelegramEntity @relation(fields: [telegramEntityId], references: [id], onDelete: Cascade)
  userId           String    @map("user_id")
  user             User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  botStartLink     String    @unique @map("bot_start_link") // Bot start link: https://t.me/bot?start=TOKEN
  token            String    @unique // Unique token for this invite (extracted for fast queries)
  durationType     Int       @map("duration_type") // TokenAction enum
  durationSeconds  Int       @map("duration_seconds") // How long member can stay AFTER joining
  memberLimit      Int?      @map("member_limit") // Max uses for this link
  currentUses      Int       @default(0) @map("current_uses")
  status           Int       @default(0) // InviteLinkStatus enum
  linkExpiresAt    DateTime? @map("link_expires_at") @db.Timestamptz(3) // When the bot link expires
  revokedAt        DateTime? @map("revoked_at") @db.Timestamptz(3)
  tokensCost       Int       @map("tokens_cost")
  metadata         Json?     // Store additional info
  createdAt        DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt        DateTime  @updatedAt @map("updated_at") @db.Timestamptz(3)
  deletedAt        DateTime? @map("deleted_at") @db.Timestamptz(3)

  @@index([userId])
  @@index([telegramEntityId])
  @@index([status])
  @@index([linkExpiresAt])
  @@index([durationType])
  @@index([token])
  @@map("invite_link")
}

// System Configuration
model Config {
  id        String   @id @default(uuid())
  key       String   @unique
  value     String
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("config")
}

// Group Members (users who joined via invites)
model GroupMember {
  id                String         @id @default(uuid())
  telegramUserId    String         @map("telegram_user_id")
  telegramEntityId  String         @map("telegram_entity_id")
  telegramEntity    TelegramEntity @relation(fields: [telegramEntityId], references: [id], onDelete: Cascade)
  username          String?
  fullName          String?        @map("full_name")
  telegramInviteLink String        @map("telegram_invite_link") // Actual Telegram group link: https://t.me/+ABC123
  joinedAt          DateTime       @default(now()) @map("joined_at") @db.Timestamptz(3)
  memberExpiresAt   DateTime       @map("member_expires_at") @db.Timestamptz(3) // When member access expires and gets kicked
  kickedAt          DateTime?      @map("kicked_at") @db.Timestamptz(3)
  isActive          Boolean        @default(true) @map("is_active")
  metadata          Json?
  createdAt         DateTime       @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt         DateTime       @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@unique([telegramUserId, telegramEntityId], name: "telegramUserId_telegramEntityId")
  @@index([telegramEntityId])
  @@index([memberExpiresAt])
  @@index([telegramInviteLink])
  @@map("group_member")
}

// Bot Member - Track all Telegram users who interact with the bot via /start
model BotMember {
  id             String    @id @default(uuid())
  telegramUserId String    @unique @map("telegram_user_id")
  username       String?
  firstName      String?   @map("first_name")
  lastName       String?   @map("last_name")
  languageCode   String?   @map("language_code")
  isPremium      Boolean   @default(false) @map("is_premium")
  isBot          Boolean   @default(false) @map("is_bot")
  lastActiveAt   DateTime  @default(now()) @map("last_active_at") @db.Timestamptz(3)
  metadata       Json?
  createdAt      DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt      DateTime  @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@index([username])
  @@index([lastActiveAt])
  @@map("bot_member")
}

// Join Log - Track every join/renewal for analytics
model JoinLog {
  id               String         @id @default(uuid())
  telegramUserId   String         @map("telegram_user_id")
  telegramEntityId String         @map("telegram_entity_id")
  telegramEntity   TelegramEntity @relation(fields: [telegramEntityId], references: [id], onDelete: Cascade)
  inviteLinkId     String         @map("invite_link_id")
  username         String?
  fullName         String?        @map("full_name")
  durationType     Int            @map("duration_type") // TokenAction enum
  durationSeconds  Int            @map("duration_seconds")
  tokensCost       Int            @map("tokens_cost")
  isRenewal        Boolean        @default(false) @map("is_renewal")
  previousExpiresAt DateTime?     @map("previous_expires_at") @db.Timestamptz(3)
  newExpiresAt     DateTime       @map("new_expires_at") @db.Timestamptz(3)
  metadata         Json?
  createdAt        DateTime       @default(now()) @map("created_at") @db.Timestamptz(3)

  @@index([telegramUserId])
  @@index([telegramEntityId])
  @@index([inviteLinkId])
  @@index([createdAt])
  @@map("join_log")
}

// Broadcast Template - Saved message templates for broadcasting
model BroadcastTemplate {
  id          String    @id @default(uuid())
  name        String
  content     String    @db.Text // Message content with optional placeholders
  parseMode   String?   @map("parse_mode") // HTML, Markdown, or null
  buttons     Json?     // Inline keyboard buttons: [[{text, url}, {text, url}], [{text, url}]]
  isActive    Boolean   @default(true) @map("is_active")
  metadata    Json?
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt   DateTime  @updatedAt @map("updated_at") @db.Timestamptz(3)
  deletedAt   DateTime? @map("deleted_at") @db.Timestamptz(3)

  broadcasts  Broadcast[]

  @@index([name])
  @@index([isActive])
  @@map("broadcast_template")
}

// Broadcast - Track broadcast sends
model Broadcast {
  id              String             @id @default(uuid())
  templateId      String?            @map("template_id")
  template        BroadcastTemplate? @relation(fields: [templateId], references: [id], onDelete: SetNull)
  content         String             @db.Text // Actual message sent (in case template was modified)
  parseMode       String?            @map("parse_mode")
  buttons         Json?              // Inline keyboard buttons used
  status          Int                @default(0) // BroadcastStatus enum: 0=pending, 1=in_progress, 2=completed, 3=failed, 4=cancelled
  totalRecipients Int                @default(0) @map("total_recipients")
  sentCount       Int                @default(0) @map("sent_count")
  failedCount     Int                @default(0) @map("failed_count")
  filterCriteria  Json?              @map("filter_criteria") // Store filter options used
  recipientIds    String[]           @map("recipient_ids") // Array of bot member IDs
  startedAt       DateTime?          @map("started_at") @db.Timestamptz(3)
  completedAt     DateTime?          @map("completed_at") @db.Timestamptz(3)
  metadata        Json?
  createdAt       DateTime           @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt       DateTime           @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@index([status])
  @@index([createdAt])
  @@map("broadcast")
}
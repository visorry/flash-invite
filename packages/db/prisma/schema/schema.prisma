generator client {
  provider     = "prisma-client"
  output       = "../generated"
  moduleFormat = "esm"
  runtime      = "bun"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============ AUTH MODELS ============

model User {
  id               String   @id @map("_id")
  name             String
  email            String
  emailVerified    Boolean
  image            String?
  isAdmin          Boolean  @default(false) @map("is_admin")
  telegramId       String?  @unique @map("telegram_id")
  telegramUsername String?  @map("telegram_username")
  createdAt        DateTime
  updatedAt        DateTime

  // Auth relations
  sessions Session[]
  accounts Account[]

  // App relations
  subscriptions     Subscription[]
  tokenBalance      TokenBalance?
  tokenTransactions TokenTransaction[]
  telegramEntities  TelegramEntity[]
  inviteLinks       InviteLink[]
  bots              Bot[]
  paymentOrders     PaymentOrder[]

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id @map("_id")
  expiresAt DateTime
  token     String
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id @map("_id")
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

model Verification {
  id         String    @id @map("_id")
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}

// ============ APP MODELS ============

// Plans
model Plan {
  id               String    @id @default(uuid())
  name             String
  description      String?
  type             Int // PlanType enum
  interval         Int // PlanInterval enum
  price            Float
  tokensIncluded   Int       @map("tokens_included")
  features         Json?
  isActive         Boolean   @default(true) @map("is_active")
  maxGroups        Int?      @map("max_groups") // null means unlimited
  maxInvitesPerDay Int?      @map("max_invites_per_day")
  metadata         Json?
  createdAt        DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt        DateTime  @updatedAt @map("updated_at") @db.Timestamptz(3)
  deletedAt        DateTime? @map("deleted_at") @db.Timestamptz(3)

  subscriptions Subscription[]

  @@map("plan")
}

// User Subscriptions
model Subscription {
  id          String    @id @default(uuid())
  userId      String    @map("user_id")
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  planId      String    @map("plan_id")
  plan        Plan      @relation(fields: [planId], references: [id])
  status      Int       @default(0) // SubscriptionStatus enum
  startDate   DateTime  @default(now()) @map("start_date") @db.Timestamptz(3)
  endDate     DateTime? @map("end_date") @db.Timestamptz(3)
  autoRenew   Boolean   @default(true) @map("auto_renew")
  cancelledAt DateTime? @map("cancelled_at") @db.Timestamptz(3)
  metadata    Json?
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt   DateTime  @updatedAt @map("updated_at") @db.Timestamptz(3)
  deletedAt   DateTime? @map("deleted_at") @db.Timestamptz(3)

  @@index([userId])
  @@index([planId])
  @@index([status])
  @@map("subscription")
}

// Token Balance
model TokenBalance {
  id          String   @id @default(uuid())
  userId      String   @unique @map("user_id")
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  balance     Int      @default(0)
  totalEarned Int      @default(0) @map("total_earned")
  totalSpent  Int      @default(0) @map("total_spent")
  metadata    Json?
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("token_balance")
}

// Token Transactions
model TokenTransaction {
  id           String    @id @default(uuid())
  userId       String    @map("user_id")
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  type         Int // TransactionType enum
  status       Int       @default(0) // TransactionStatus enum
  amount       Int // Positive for credit, negative for debit
  balanceAfter Int       @map("balance_after")
  description  String?
  reference    String? // External reference like payment ID, invite link ID, etc.
  metadata     Json? // Store additional info
  createdAt    DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt    DateTime  @updatedAt @map("updated_at") @db.Timestamptz(3)
  deletedAt    DateTime? @map("deleted_at") @db.Timestamptz(3)

  @@index([userId])
  @@index([type])
  @@index([status])
  @@index([createdAt])
  @@index([reference])
  @@map("token_transaction")
}

// Token Cost Configuration - pricing per duration unit
model TokenCostConfig {
  id           String    @id @default(uuid())
  durationUnit Int       @unique @map("duration_unit") // DurationUnit enum (0=minute, 1=hour, 2=day, 3=month, 4=year)
  costPerUnit  Int       @map("cost_per_unit") // tokens per unit
  description  String?
  isActive     Boolean   @default(true) @map("is_active")
  metadata     Json?
  createdAt    DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt    DateTime  @updatedAt @map("updated_at") @db.Timestamptz(3)
  deletedAt    DateTime? @map("deleted_at") @db.Timestamptz(3)

  @@map("token_cost_config")
}

// Bot Cost Configuration - pricing for creating additional bots
model BotCostConfig {
  id              String   @id @default(uuid())
  costPerBot      Int      @map("cost_per_bot") // tokens required for additional bot
  freeBotsAllowed Int      @default(1) @map("free_bots_allowed") // number of free bots per user
  description     String?
  isActive        Boolean  @default(true) @map("is_active")
  metadata        Json?
  createdAt       DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt       DateTime @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("bot_cost_config")
}

// Automation Cost Configuration - pricing for automation features (auto-approval, forward rules)
model AutomationCostConfig {
  id               String    @id @default(uuid())
  featureType      Int       @unique @map("feature_type") // 0=auto_approval, 1=forward_rule
  costPerRule      Int       @map("cost_per_rule") // tokens required per rule
  freeRulesAllowed Int       @default(1) @map("free_rules_allowed") // number of free rules per user
  description      String?
  isActive         Boolean   @default(true) @map("is_active")
  metadata         Json?
  createdAt        DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt        DateTime  @updatedAt @map("updated_at") @db.Timestamptz(3)
  deletedAt        DateTime? @map("deleted_at") @db.Timestamptz(3)

  @@map("automation_cost_config")
}

// User's Telegram Bots
model Bot {
  id              String    @id @default(uuid())
  userId          String    @map("user_id")
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  token           String // Bot token (should be encrypted in production)
  username        String // Bot username without @
  firstName       String    @map("first_name") // Bot display name
  botId           String    @unique @map("bot_id") // Telegram bot ID
  status          Int       @default(0) // BotStatus enum: 0=active, 1=inactive, 2=error
  isDefault       Boolean   @default(false) @map("is_default")
  lastHealthCheck DateTime? @map("last_health_check") @db.Timestamptz(3)
  errorMessage    String?   @map("error_message")
  metadata        Json?
  createdAt       DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt       DateTime  @updatedAt @map("updated_at") @db.Timestamptz(3)
  deletedAt       DateTime? @map("deleted_at") @db.Timestamptz(3)

  entityLinks       BotTelegramEntity[]
  inviteLinks       InviteLink[]
  botMembers        BotMember[]
  forwardRules      ForwardRule[]
  broadcasts        Broadcast[]
  autoApprovalRules AutoApprovalRule[]
  welcomeConfigs    WelcomeConfig[]

  @@index([userId])
  @@index([status])
  @@index([isDefault])
  @@map("bot")
}

// Bot-TelegramEntity Junction Table (Many-to-Many)
model BotTelegramEntity {
  id               String         @id @default(uuid())
  botId            String         @map("bot_id")
  bot              Bot            @relation(fields: [botId], references: [id], onDelete: Cascade)
  telegramEntityId String         @map("telegram_entity_id")
  telegramEntity   TelegramEntity @relation(fields: [telegramEntityId], references: [id], onDelete: Cascade)
  isAdmin          Boolean        @default(false) @map("is_admin")
  adminPermissions Json?          @map("admin_permissions") // Store bot's admin rights in this chat
  isPrimary        Boolean        @default(false) @map("is_primary") // Primary bot for invite links
  syncedAt         DateTime?      @map("synced_at") @db.Timestamptz(3)
  metadata         Json?
  createdAt        DateTime       @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt        DateTime       @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@unique([botId, telegramEntityId])
  @@index([botId])
  @@index([telegramEntityId])
  @@index([isPrimary])
  @@map("bot_telegram_entity")
}

// Telegram Groups/Channels
model TelegramEntity {
  id          String    @id @default(uuid())
  userId      String    @map("user_id")
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  telegramId  String    @map("telegram_id") // Telegram's chat ID
  type        Int // TelegramEntityType enum
  title       String
  username    String? // @username if available
  description String?
  memberCount Int?      @map("member_count")
  isActive    Boolean   @default(true) @map("is_active")
  metadata    Json? // Store additional telegram data
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt   DateTime  @updatedAt @map("updated_at") @db.Timestamptz(3)
  deletedAt   DateTime? @map("deleted_at") @db.Timestamptz(3)

  botLinks             BotTelegramEntity[]
  inviteLinks          InviteLink[]
  groupMembers         GroupMember[]
  joinLogs             JoinLog[]
  forwardRulesAsSource ForwardRule[]       @relation("ForwardSource")
  forwardRulesAsDest   ForwardRule[]       @relation("ForwardDestination")
  autoApprovalRules    AutoApprovalRule[]
  welcomeConfigs       WelcomeConfig[]

  @@unique([telegramId, userId]) // Same group can exist for different users
  @@index([userId])
  @@index([telegramId])
  @@index([type])
  @@map("telegram_entity")
}

// Invite Links
model InviteLink {
  id               String         @id @default(uuid())
  telegramEntityId String         @map("telegram_entity_id")
  telegramEntity   TelegramEntity @relation(fields: [telegramEntityId], references: [id], onDelete: Cascade)
  userId           String         @map("user_id")
  user             User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  botId            String         @map("bot_id")
  bot              Bot            @relation(fields: [botId], references: [id], onDelete: Cascade)
  botStartLink     String         @unique @map("bot_start_link") // Bot start link: https://t.me/bot?start=TOKEN
  token            String         @unique // Unique token for this invite (extracted for fast queries)
  durationType     Int            @map("duration_type") // TokenAction enum
  durationSeconds  Int            @map("duration_seconds") // How long member can stay AFTER joining
  memberLimit      Int?           @map("member_limit") // Max uses for this link
  currentUses      Int            @default(0) @map("current_uses")
  status           Int            @default(0) // InviteLinkStatus enum
  linkExpiresAt    DateTime?      @map("link_expires_at") @db.Timestamptz(3) // When the bot link expires
  revokedAt        DateTime?      @map("revoked_at") @db.Timestamptz(3)
  tokensCost       Int            @map("tokens_cost")
  metadata         Json? // Store additional info
  createdAt        DateTime       @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt        DateTime       @updatedAt @map("updated_at") @db.Timestamptz(3)
  deletedAt        DateTime?      @map("deleted_at") @db.Timestamptz(3)

  @@index([userId])
  @@index([telegramEntityId])
  @@index([botId])
  @@index([status])
  @@index([linkExpiresAt])
  @@index([durationType])
  @@index([token])
  @@map("invite_link")
}

// System Configuration
model Config {
  id        String   @id @default(uuid())
  key       String   @unique
  value     String
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("config")
}

// Group Members (users who joined via invites)
model GroupMember {
  id                 String         @id @default(uuid())
  telegramUserId     String         @map("telegram_user_id")
  telegramEntityId   String         @map("telegram_entity_id")
  telegramEntity     TelegramEntity @relation(fields: [telegramEntityId], references: [id], onDelete: Cascade)
  username           String?
  fullName           String?        @map("full_name")
  telegramInviteLink String         @map("telegram_invite_link") // Actual Telegram group link: https://t.me/+ABC123
  joinedAt           DateTime       @default(now()) @map("joined_at") @db.Timestamptz(3)
  memberExpiresAt    DateTime       @map("member_expires_at") @db.Timestamptz(3) // When member access expires and gets kicked
  kickedAt           DateTime?      @map("kicked_at") @db.Timestamptz(3)
  isActive           Boolean        @default(true) @map("is_active")
  metadata           Json?
  createdAt          DateTime       @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt          DateTime       @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@unique([telegramUserId, telegramEntityId], name: "telegramUserId_telegramEntityId")
  @@index([telegramEntityId])
  @@index([memberExpiresAt])
  @@index([telegramInviteLink])
  @@map("group_member")
}

// Bot Member - Track all Telegram users who interact with a bot via /start
model BotMember {
  id             String   @id @default(uuid())
  botId          String   @map("bot_id")
  bot            Bot      @relation(fields: [botId], references: [id], onDelete: Cascade)
  telegramUserId String   @map("telegram_user_id")
  username       String?
  firstName      String?  @map("first_name")
  lastName       String?  @map("last_name")
  languageCode   String?  @map("language_code")
  isPremium      Boolean  @default(false) @map("is_premium")
  isBot          Boolean  @default(false) @map("is_bot")
  lastActiveAt   DateTime @default(now()) @map("last_active_at") @db.Timestamptz(3)
  metadata       Json?
  createdAt      DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt      DateTime @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@unique([botId, telegramUserId]) // Same user can interact with different bots
  @@index([botId])
  @@index([telegramUserId])
  @@index([username])
  @@index([lastActiveAt])
  @@map("bot_member")
}

// Join Log - Track every join/renewal for analytics
model JoinLog {
  id                String         @id @default(uuid())
  telegramUserId    String         @map("telegram_user_id")
  telegramEntityId  String         @map("telegram_entity_id")
  telegramEntity    TelegramEntity @relation(fields: [telegramEntityId], references: [id], onDelete: Cascade)
  inviteLinkId      String         @map("invite_link_id")
  username          String?
  fullName          String?        @map("full_name")
  durationType      Int            @map("duration_type") // TokenAction enum
  durationSeconds   Int            @map("duration_seconds")
  tokensCost        Int            @map("tokens_cost")
  isRenewal         Boolean        @default(false) @map("is_renewal")
  previousExpiresAt DateTime?      @map("previous_expires_at") @db.Timestamptz(3)
  newExpiresAt      DateTime       @map("new_expires_at") @db.Timestamptz(3)
  metadata          Json?
  createdAt         DateTime       @default(now()) @map("created_at") @db.Timestamptz(3)

  @@index([telegramUserId])
  @@index([telegramEntityId])
  @@index([inviteLinkId])
  @@index([createdAt])
  @@map("join_log")
}

// Broadcast Template - Saved message templates for broadcasting
model BroadcastTemplate {
  id        String    @id @default(uuid())
  name      String
  content   String    @db.Text // Message content with optional placeholders
  parseMode String?   @map("parse_mode") // HTML, Markdown, or null
  buttons   Json? // Inline keyboard buttons: [[{text, url}, {text, url}], [{text, url}]]
  isActive  Boolean   @default(true) @map("is_active")
  metadata  Json?
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime  @updatedAt @map("updated_at") @db.Timestamptz(3)
  deletedAt DateTime? @map("deleted_at") @db.Timestamptz(3)

  broadcasts Broadcast[]

  @@index([name])
  @@index([isActive])
  @@map("broadcast_template")
}

// Broadcast - Track broadcast sends
model Broadcast {
  id              String             @id @default(uuid())
  botId           String             @map("bot_id")
  bot             Bot                @relation(fields: [botId], references: [id], onDelete: Cascade)
  templateId      String?            @map("template_id")
  template        BroadcastTemplate? @relation(fields: [templateId], references: [id], onDelete: SetNull)
  content         String             @db.Text // Actual message sent (in case template was modified)
  parseMode       String?            @map("parse_mode")
  buttons         Json? // Inline keyboard buttons used
  status          Int                @default(0) // BroadcastStatus enum: 0=pending, 1=in_progress, 2=completed, 3=failed, 4=cancelled
  totalRecipients Int                @default(0) @map("total_recipients")
  sentCount       Int                @default(0) @map("sent_count")
  failedCount     Int                @default(0) @map("failed_count")
  filterCriteria  Json?              @map("filter_criteria") // Store filter options used
  recipientIds    String[]           @map("recipient_ids") // Array of bot member IDs
  startedAt       DateTime?          @map("started_at") @db.Timestamptz(3)
  completedAt     DateTime?          @map("completed_at") @db.Timestamptz(3)
  metadata        Json?
  createdAt       DateTime           @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt       DateTime           @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@index([botId])
  @@index([status])
  @@index([createdAt])
  @@map("broadcast")
}

// Telegram Login Token - Temporary tokens for Telegram login flow
model TelegramLoginToken {
  id             String   @id @default(uuid())
  token          String   @unique
  telegramUserId String?  @map("telegram_user_id")
  username       String?
  fullName       String?  @map("full_name")
  expiresAt      DateTime @map("expires_at") @db.Timestamptz(3)
  createdAt      DateTime @default(now()) @map("created_at") @db.Timestamptz(3)

  @@index([token])
  @@index([expiresAt])
  @@map("telegram_login_token")
}

// Forward Rule - Automatic message forwarding between chats
model ForwardRule {
  id                  String         @id @default(uuid())
  userId              String         @map("user_id")
  botId               String         @map("bot_id")
  bot                 Bot            @relation(fields: [botId], references: [id], onDelete: Cascade)
  sourceEntityId      String         @map("source_entity_id")
  sourceEntity        TelegramEntity @relation("ForwardSource", fields: [sourceEntityId], references: [id], onDelete: Cascade)
  destinationEntityId String         @map("destination_entity_id")
  destinationEntity   TelegramEntity @relation("ForwardDestination", fields: [destinationEntityId], references: [id], onDelete: Cascade)
  name                String // User-friendly name for the rule
  isActive            Boolean        @default(true) @map("is_active")

  // Scheduling mode: 0=realtime, 1=scheduled
  scheduleMode    Int @default(0) @map("schedule_mode")
  intervalMinutes Int @default(30) @map("interval_minutes") // Time between scheduled posts

  // Range selection for scheduled mode
  startFromMessageId Int? @map("start_from_message_id") // Starting message ID
  endAtMessageId     Int? @map("end_at_message_id") // Ending message ID (null = no end)

  // Behavior options
  shuffle        Boolean @default(false) // Randomize post order
  repeatWhenDone Boolean @default(false) @map("repeat_when_done") // Loop when finished

  // Progress tracking
  lastProcessedMsgId Int?      @map("last_processed_msg_id") // Track progress
  nextRunAt          DateTime? @map("next_run_at") @db.Timestamptz(3) // Next scheduled run
  messageQueue       Int[]     @map("message_queue") // Queue of message IDs to process

  // Schedule status: 0=idle, 1=running, 2=paused, 3=completed
  scheduleStatus Int @default(0) @map("schedule_status")

  // Content filters
  forwardMedia     Boolean @default(true) @map("forward_media") // Forward photos, videos, etc.
  forwardText      Boolean @default(true) @map("forward_text")
  forwardDocuments Boolean @default(true) @map("forward_documents")
  forwardStickers  Boolean @default(false) @map("forward_stickers")
  forwardPolls     Boolean @default(true) @map("forward_polls")

  // Text modifications
  removeLinks  Boolean @default(false) @map("remove_links") // Strip URLs from text
  addWatermark String? @map("add_watermark") // Text to append to forwarded messages

  // Keyword filters (JSON arrays)
  includeKeywords String[] @map("include_keywords") // Only forward if contains these
  excludeKeywords String[] @map("exclude_keywords") // Don't forward if contains these

  // Stats
  forwardedCount  Int       @default(0) @map("forwarded_count")
  lastForwardedAt DateTime? @map("last_forwarded_at") @db.Timestamptz(3)

  metadata  Json?
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime  @updatedAt @map("updated_at") @db.Timestamptz(3)
  deletedAt DateTime? @map("deleted_at") @db.Timestamptz(3)

  @@unique([botId, sourceEntityId, destinationEntityId]) // One rule per source-dest pair per bot
  @@index([userId])
  @@index([botId])
  @@index([sourceEntityId])
  @@index([destinationEntityId])
  @@index([isActive])
  @@index([scheduleMode])
  @@index([nextRunAt])
  @@map("forward_rule")
}

// Auto Approval Rule - Automatically approve join requests
model AutoApprovalRule {
  id               String         @id @default(uuid())
  userId           String         @map("user_id")
  botId            String         @map("bot_id")
  bot              Bot            @relation(fields: [botId], references: [id], onDelete: Cascade)
  telegramEntityId String         @map("telegram_entity_id")
  telegramEntity   TelegramEntity @relation(fields: [telegramEntityId], references: [id], onDelete: Cascade)
  name             String // User-friendly name
  isActive         Boolean        @default(true) @map("is_active")

  // Approval mode: 0=instant, 1=delayed, 2=captcha
  approvalMode Int @default(0) @map("approval_mode")
  delaySeconds Int @default(0) @map("delay_seconds") // For delayed mode

  // Filters
  requirePremium   Boolean  @default(false) @map("require_premium")
  requireUsername  Boolean  @default(false) @map("require_username")
  minAccountAge    Int?     @map("min_account_age") // Days
  blockedCountries String[] @map("blocked_countries") // ISO country codes

  // Actions after approval
  sendWelcomeMsg Boolean @default(false) @map("send_welcome_msg")
  welcomeMessage String? @map("welcome_message") @db.Text

  // Stats
  approvedCount  Int       @default(0) @map("approved_count")
  rejectedCount  Int       @default(0) @map("rejected_count")
  lastApprovedAt DateTime? @map("last_approved_at") @db.Timestamptz(3)

  metadata  Json?
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@unique([botId, telegramEntityId]) // One rule per entity per bot
  @@index([userId])
  @@index([botId])
  @@index([telegramEntityId])
  @@index([isActive])
  @@map("auto_approval_rule")
}

// Welcome/Goodbye Message Configuration
model WelcomeConfig {
  id               String         @id @default(uuid())
  userId           String         @map("user_id")
  botId            String         @map("bot_id")
  bot              Bot            @relation(fields: [botId], references: [id], onDelete: Cascade)
  telegramEntityId String         @map("telegram_entity_id")
  telegramEntity   TelegramEntity @relation(fields: [telegramEntityId], references: [id], onDelete: Cascade)

  // Welcome settings
  welcomeEnabled   Boolean @default(false) @map("welcome_enabled")
  welcomeMessage   String? @map("welcome_message") @db.Text
  welcomeParseMode String? @map("welcome_parse_mode") // HTML, Markdown
  welcomeButtons   Json?   @map("welcome_buttons") // Inline keyboard

  // Goodbye settings
  goodbyeEnabled   Boolean @default(false) @map("goodbye_enabled")
  goodbyeMessage   String? @map("goodbye_message") @db.Text
  goodbyeParseMode String? @map("goodbye_parse_mode")

  // Options
  deleteAfterSecs Int?    @map("delete_after_secs") // Auto-delete welcome after X seconds
  mentionUser     Boolean @default(true) @map("mention_user")

  metadata  Json?
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@unique([botId, telegramEntityId])
  @@index([userId])
  @@index([botId])
  @@index([telegramEntityId])
  @@map("welcome_config")
}

// ============ PAYMENT MODELS ============

model PaymentOrder {
  id               String   @id @default(uuid())
  userId           String   @map("user_id")
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  orderId          String   @unique @map("order_id") // Cashfree order ID
  amount           Float
  currency         String   @default("INR")
  status           Int // PaymentStatus enum
  type             Int // PaymentType enum: 0=SUBSCRIPTION, 1=TOKEN_BUNDLE
  referenceId      String?  @map("reference_id") // Plan ID or TokenBundle ID
  paymentSessionId String?  @map("payment_session_id")
  metadata         Json?
  createdAt        DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt        DateTime @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@index([userId])
  @@index([status])
  @@index([orderId])
  @@map("payment_order")
}

model TokenBundle {
  id          String    @id @default(uuid())
  name        String
  description String?
  tokens      Int
  price       Float
  currency    String    @default("INR")
  isActive    Boolean   @default(true) @map("is_active")
  metadata    Json?
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt   DateTime  @updatedAt @map("updated_at") @db.Timestamptz(3)
  deletedAt   DateTime? @map("deleted_at") @db.Timestamptz(3)

  @@map("token_bundle")
}
